### 1. Variables and Data Types

Variables store values. Python automatically detects the type.

Common types: int, float, str, bool, list, tuple, set, dict.
```python
# Numbers
x = 10      # int
y = 3.14    # float

# Strings
name = "Alice"

# Boolean
is_active = True

# Multiple assignment
a, b, c = 1, 2, 3

# Type conversion
z = int("5")  # str -> int
f = float(10) # int -> float
```
### 2. Operators

Arithmetic: + - * / % ** //

Comparison: == != > < >= <=

Logical: and, or, not

Assignment: =, +=, -=, *=, /=
```python
a = 10
b = 3

print(a + b)  # Addition
print(a % b)  # Remainder
print(a ** b) # Power

# Logical
print(a > 5 and b < 5)  # True

```

### 3. Strings (Text Data)

Strings are sequences of characters.

You can index, slice, and use built-in methods.
```python
text = "Hello, World!"

# Indexing & slicing
print(text[0])    # 'H'
print(text[0:5])  # 'Hello'


# Methods
print(text.lower())          # 'hello, world!'
print(text.upper())          # 'HELLO, WORLD!'
print(text.replace("World", "Python")) # 'Hello, Python!'
print(text.split(","))       # ['Hello', ' World!']
print(text.strip())          # removes whitespace

# Check content
print(text.startswith("Hello"))  # True
print(text.endswith("!"))        # True
print("World" in text)           # True
```
### 4. Lists

Lists are ordered, mutable collections.

Common operations: add, remove, slice, iterate.
```python
fruits = ["apple", "banana", "cherry"]

# Add elements
fruits.append("orange")
fruits.insert(1, "kiwi")  # insert at index 1

# Remove elements
fruits.remove("banana")
popped = fruits.pop()      # removes last element

# Access & slice
print(fruits[0])  # 'apple'
print(fruits[-1]) # last element

# Loop
for fruit in fruits:
    print(fruit)

# Comprehension
squares = [x**2 for x in range(5)]

```
### Type Cast
```python
x = 10        # int
y = 3.14      # float
name = "Alice" # str
is_active = True  # bool

# Multiple assignment
a, b, c = 1, 2, 3

# Type conversion
int_val = int("5")    # '5' -> 5
float_val = float(10) # 10 -> 10.0
str_val = str(100)    # 100 -> '100'

```
### 5. Tuples
Ordered, immutable collections.
```python
coordinates = (10, 20)
print(coordinates[0])   # 10
# coordinates[0] = 5    # ❌ Error, cannot modify

```
### 6. Sets

Unordered collections with no duplicates. 
```python
numbers = {1, 2, 3, 2}
numbers.add(4)
numbers.remove(1)
print(numbers)  # {2,3,4}

# Set operations
a = {1,2,3}
b = {3,4,5}
print(a | b)  # Union {1,2,3,4,5}
print(a & b)  # Intersection {3}
print(a - b)  # Difference {1,2}

```
### 7. Dictionaries

Key-value pairs, unordered, mutable.
### 
```python
person = {"name": "Alice", "age": 25}

# Access
print(person["name"])

# Add/update
person["city"] = "NY"
person["age"] = 26

# Remove
person.pop("city")

# Loop
for key, value in person.items():
    print(key, value)

```
### 8. Conditional Statements
```python
x = 10
if x > 0:
    print("Positive")
elif x == 0:
    print("Zero")
else:
    print("Negative")

```
### 9. Loops

For loop:
### 
```python
for i in range(5):  # 0,1,2,3,4
    print(i)
# While loop

count = 0
while count < 5:
    print(count)
    count += 1


```
### Break & Continue:
```python

for i in range(5):
    if i == 3:
        break   # stop loop
    if i == 1:
        continue  # skip this iteration
    print(i)

```
### 10. Functions
```python
def greet(name):
    return f"Hello, {name}!"

print(greet("Alice"))

# Lambda function
square = lambda x: x**2
print(square(5))

```
### 11. Modules & Libraries
```python
import math
print(math.sqrt(16))  # 4.0

from random import randint
print(randint(1, 10))

```
### 12. File I/O
```python
# Read
with open("file.txt", "r") as f:
    content = f.read()
    print(content)

# Write
with open("file.txt", "w") as f:
    f.write("Hello, Python!")

```
### 13. Exception Handling
```python
try:
    x = int(input("Enter a number: "))
    print(10 / x)
except ValueError:
    print("Invalid number!")
except ZeroDivisionError:
    print("Cannot divide by zero!")
finally:
    print("Execution done.")

```
### 14. Classes & OOP
Explanation:

__init__ initializes objects

self refers to the current instance

```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def greet(self):
        return f"Hello, I am {self.name}"

p = Person("Alice", 25)
print(p.greet())

```
### 15. Useful Built-in Functions

len(), type(), str(), int(), float(), sum(), max(), min(), sorted(), range(), enumerate()
```python

nums = [3, 1, 5]
print(len(nums))    # 3
print(max(nums))    # 5
for i, val in enumerate(nums):
    print(i, val)

```
### 1. List, Set, Dictionary Comprehensions

Concise way to create collections from iterables.
```python

# List comprehension
squares = [x**2 for x in range(10) if x % 2 == 0] #List: [0, 4, 16, 36, 64]

# Dictionary comprehension
square_dict = {x: x**2 for x in range(5)}    #Dict: {0: 0, 1: 1, 2: 4, 3: 9, 4: 16}

# Set comprehension
even_set = {x for x in range(10) if x % 2 == 0}  #Set: {0, 2, 4, 6, 8}

print(squares)
print(square_dict)
print(even_set)

```
### 2. Lambda Functions (Anonymous Functions)
```python
square = lambda x: x**2
add = lambda x, y: x + y

print(square(5))
print(add(3, 7))

# With map/filter
nums = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, nums))
evens = list(filter(lambda x: x % 2 == 0, nums))
```

### 3. map, filter, reduce

map: Apply a function to all elements

filter: Keep elements that satisfy a condition

reduce (from functools): Reduce a sequence to a single value

```python

from functools import reduce

nums = [1, 2, 3, 4]

# Map
squared = list(map(lambda x: x**2, nums))

# Filter
evens = list(filter(lambda x: x % 2 == 0, nums))

# Reduce
sum_all = reduce(lambda x, y: x + y, nums)

print(squared, evens, sum_all)


```

### 4. Generators & Iterators

Efficient memory usage for large sequences.

```python
# Generator function
def gen_numbers(n):
    for i in range(n):
        yield i*i

g = gen_numbers(5)
print(next(g))  # 0
print(next(g))  # 1

# Generator expression
gen_exp = (x**2 for x in range(5))
print(list(gen_exp))
```
### 5. Decorators

Functions that modify other functions.

```python
def decorator(func):
    def wrapper():
        print("Before function")
        func()
        print("After function")
    return wrapper

@decorator
def greet():
    print("Hello!")

greet()

```
### 6. Context Managers
Manage resources (like files) safely using with.

```python
with open("file.txt", "w") as f:
    f.write("Hello, Advanced Python!")

# Custom context manager
class MyManager:
    def __enter__(self):
        print("Enter")
        return self
    def __exit__(self, exc_type, exc_value, traceback):
        print("Exit")

with MyManager() as m:
    print("Inside context")

#output
Enter
Inside context
Exit

#Summary
#File example: with automatically manages resources (like closing a file).
#Custom manager: You can define your own context behavior with __enter__ and __exit__.
#Useful for: files, database connections, locks, network connections, or any resource that needs cleanu
```
### Step-by-Step:

__enter__ method

Runs at the start of the with block.

Its return value (self here) is assigned to the variable m.

Prints: "Enter"

__exit__ method

Runs at the end of the with block, even if there is an error inside.

Prints: "Exit"

Inside the with block

Executes print("Inside context").

### 7. Regular Expressions (re module)

Powerful string pattern matching.

Common Functions:

re.search(), re.match(), re.findall(), re.sub()

```python
import re

text = "My phone number is 123-456-7890"
pattern = r"\d{3}-\d{3}-\d{4}"

match = re.search(pattern, text)
if match:
    print("Found:", match.group())

#op
Found: 123-456-7890
```
### Step 1: Understanding the Regex

\d → matches any digit (0–9)

{3} → exactly 3 digits

- → literal dash

So \d{3}-\d{3}-\d{4} matches a pattern like 123-456-7890

re.search()

Searches the first occurrence of the pattern in text.

Returns a match object if found, None if not.

match.group()

Retrieves the matched string from the match object.

### Itertools Module

Functions for advanced iteration.

```python
import itertools

# Infinite counter
count = itertools.count(10)
print(next(count), next(count))  # 10, 11

# Combinations
items = ['a', 'b', 'c']
comb = list(itertools.combinations(items, 2))
print(comb)  # [('a','b'), ('a','c'), ('b','c')]

# Permutations
perm = list(itertools.permutations(items))
print(perm)


```
### Collections Module

Advanced data structures.

```python
from collections import Counter, defaultdict, deque, namedtuple

# Counter
words = ["apple", "banana", "apple"]
print(Counter(words))  # {'apple': 2, 'banana': 1}

# defaultdict
d = defaultdict(int)
d['a'] += 1
print(d)

# deque (double-ended queue)
dq = deque([1,2,3])
dq.appendleft(0)
dq.pop()
print(dq)

# namedtuple
Point = namedtuple('Point', ['x','y'])
p = Point(10, 20)
print(p.x, p.y)
```

### defaultdict(int) means default value for any missing key is 0.
d['a'] += 1 → 0 + 1 = 1

Prints the dictionary.

defaultdict(<class 'int'>, {'a': 1})

### # deque (double-ended queue) 
Start: [1,2,3]

After appendleft(0): [0,1,2,3]

After pop(): [0,1,2]
op - deque([0, 1, 2])

### Advanced OOP

Inheritance, polymorphism, encapsulation, class/static methods.

```python

class Animal:
    def speak(self):
        print("Animal speaks")

class Dog(Animal):
    def speak(self):
        print("Dog barks")

dog = Dog()
dog.speak()  # Dog barks

# Class & static methods
class Math:
    @staticmethod
    def add(a, b):
        return a + b
    @classmethod
    def info(cls):
        print("Class:", cls.__name__)

print(Math.add(2,3))
Math.info()


```
### 12. Concurrency

Threads, asyncio for async programming.

```python

# Thread example
from threading import Thread

def task():
    print("Task executed")

t = Thread(target=task)
t.start()
t.join()

# Asyncio example
import asyncio

async def say_hello():
    await asyncio.sleep(1)
    print("Hello Async")

asyncio.run(say_hello())
```

